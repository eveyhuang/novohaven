{"ast":null,"code":"import _objectSpread from\"/Users/eveyhuang/Documents/novohaven-app/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useCallback,useRef,useEffect}from'react';import api from'../services/api';import{jsx as _jsx}from\"react/jsx-runtime\";const NotificationContext=/*#__PURE__*/createContext(undefined);export function NotificationProvider(_ref){let{children}=_ref;const[notifications,setNotifications]=useState([]);const[backgroundExecutions,setBackgroundExecutions]=useState([]);const pollingIntervalRef=useRef(null);const addNotification=useCallback(notification=>{var _notification$autoClo,_notification$duratio;const id=\"notification-\".concat(Date.now(),\"-\").concat(Math.random().toString(36).substr(2,9));const newNotification=_objectSpread(_objectSpread({},notification),{},{id,autoClose:(_notification$autoClo=notification.autoClose)!==null&&_notification$autoClo!==void 0?_notification$autoClo:true,duration:(_notification$duratio=notification.duration)!==null&&_notification$duratio!==void 0?_notification$duratio:5000});setNotifications(prev=>[...prev,newNotification]);// Auto-close after duration\nif(newNotification.autoClose){setTimeout(()=>{removeNotification(id);},newNotification.duration);}return id;},[]);const removeNotification=useCallback(id=>{setNotifications(prev=>prev.filter(n=>n.id!==id));},[]);const clearAll=useCallback(()=>{setNotifications([]);},[]);const trackExecution=useCallback((executionId,recipeName)=>{setBackgroundExecutions(prev=>{// Don't add if already tracking\nif(prev.some(e=>e.id===executionId)){return prev;}return[...prev,{id:executionId,recipeName,status:'running',startedAt:new Date()}];});},[]);const stopTracking=useCallback(executionId=>{setBackgroundExecutions(prev=>prev.filter(e=>e.id!==executionId));},[]);// Poll for execution status changes\nuseEffect(()=>{if(backgroundExecutions.length===0){if(pollingIntervalRef.current){clearInterval(pollingIntervalRef.current);pollingIntervalRef.current=null;}return;}const pollExecutions=async()=>{for(const exec of backgroundExecutions){try{const status=await api.getExecutionStatus(exec.id);// Check if status changed to completed, failed, or paused (awaiting review)\nif(status.status==='completed'){addNotification({type:'success',title:'Workflow Completed',message:\"\\\"\".concat(exec.recipeName,\"\\\" has finished successfully.\"),executionId:exec.id,recipeName:exec.recipeName,autoClose:false});stopTracking(exec.id);}else if(status.status==='failed'){addNotification({type:'error',title:'Workflow Failed',message:\"\\\"\".concat(exec.recipeName,\"\\\" encountered an error.\"),executionId:exec.id,recipeName:exec.recipeName,autoClose:false});stopTracking(exec.id);}else if(status.status==='paused'){// Execution is paused - typically means a step is awaiting review\naddNotification({type:'info',title:'Review Required',message:\"\\\"\".concat(exec.recipeName,\"\\\" is waiting for your review.\"),executionId:exec.id,recipeName:exec.recipeName,autoClose:false});stopTracking(exec.id);}}catch(error){console.error(\"Error polling execution \".concat(exec.id,\":\"),error);}}};// Initial poll\npollExecutions();// Set up interval polling (every 3 seconds)\npollingIntervalRef.current=setInterval(pollExecutions,3000);return()=>{if(pollingIntervalRef.current){clearInterval(pollingIntervalRef.current);}};},[backgroundExecutions,addNotification,stopTracking]);return/*#__PURE__*/_jsx(NotificationContext.Provider,{value:{notifications,addNotification,removeNotification,clearAll,backgroundExecutions,trackExecution,stopTracking},children:children});}export function useNotifications(){const context=useContext(NotificationContext);if(!context){throw new Error('useNotifications must be used within a NotificationProvider');}return context;}","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useRef","useEffect","api","jsx","_jsx","NotificationContext","undefined","NotificationProvider","_ref","children","notifications","setNotifications","backgroundExecutions","setBackgroundExecutions","pollingIntervalRef","addNotification","notification","_notification$autoClo","_notification$duratio","id","concat","Date","now","Math","random","toString","substr","newNotification","_objectSpread","autoClose","duration","prev","setTimeout","removeNotification","filter","n","clearAll","trackExecution","executionId","recipeName","some","e","status","startedAt","stopTracking","length","current","clearInterval","pollExecutions","exec","getExecutionStatus","type","title","message","error","console","setInterval","Provider","value","useNotifications","context","Error"],"sources":["/Users/eveyhuang/Documents/novohaven-app/client/src/context/NotificationContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport api from '../services/api';\n\nexport interface Notification {\n  id: string;\n  type: 'success' | 'error' | 'info' | 'warning';\n  title: string;\n  message?: string;\n  executionId?: number;\n  recipeName?: string;\n  autoClose?: boolean;\n  duration?: number;\n}\n\ninterface BackgroundExecution {\n  id: number;\n  recipeName: string;\n  status: string;\n  startedAt: Date;\n}\n\ninterface NotificationContextType {\n  notifications: Notification[];\n  addNotification: (notification: Omit<Notification, 'id'>) => string;\n  removeNotification: (id: string) => void;\n  clearAll: () => void;\n  // Background execution tracking\n  backgroundExecutions: BackgroundExecution[];\n  trackExecution: (executionId: number, recipeName: string) => void;\n  stopTracking: (executionId: number) => void;\n}\n\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\n\nexport function NotificationProvider({ children }: { children: React.ReactNode }) {\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const [backgroundExecutions, setBackgroundExecutions] = useState<BackgroundExecution[]>([]);\n  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  const addNotification = useCallback((notification: Omit<Notification, 'id'>) => {\n    const id = `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const newNotification: Notification = {\n      ...notification,\n      id,\n      autoClose: notification.autoClose ?? true,\n      duration: notification.duration ?? 5000,\n    };\n\n    setNotifications(prev => [...prev, newNotification]);\n\n    // Auto-close after duration\n    if (newNotification.autoClose) {\n      setTimeout(() => {\n        removeNotification(id);\n      }, newNotification.duration);\n    }\n\n    return id;\n  }, []);\n\n  const removeNotification = useCallback((id: string) => {\n    setNotifications(prev => prev.filter(n => n.id !== id));\n  }, []);\n\n  const clearAll = useCallback(() => {\n    setNotifications([]);\n  }, []);\n\n  const trackExecution = useCallback((executionId: number, recipeName: string) => {\n    setBackgroundExecutions(prev => {\n      // Don't add if already tracking\n      if (prev.some(e => e.id === executionId)) {\n        return prev;\n      }\n      return [...prev, {\n        id: executionId,\n        recipeName,\n        status: 'running',\n        startedAt: new Date(),\n      }];\n    });\n  }, []);\n\n  const stopTracking = useCallback((executionId: number) => {\n    setBackgroundExecutions(prev => prev.filter(e => e.id !== executionId));\n  }, []);\n\n  // Poll for execution status changes\n  useEffect(() => {\n    if (backgroundExecutions.length === 0) {\n      if (pollingIntervalRef.current) {\n        clearInterval(pollingIntervalRef.current);\n        pollingIntervalRef.current = null;\n      }\n      return;\n    }\n\n    const pollExecutions = async () => {\n      for (const exec of backgroundExecutions) {\n        try {\n          const status = await api.getExecutionStatus(exec.id);\n\n          // Check if status changed to completed, failed, or paused (awaiting review)\n          if (status.status === 'completed') {\n            addNotification({\n              type: 'success',\n              title: 'Workflow Completed',\n              message: `\"${exec.recipeName}\" has finished successfully.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false,\n            });\n            stopTracking(exec.id);\n          } else if (status.status === 'failed') {\n            addNotification({\n              type: 'error',\n              title: 'Workflow Failed',\n              message: `\"${exec.recipeName}\" encountered an error.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false,\n            });\n            stopTracking(exec.id);\n          } else if (status.status === 'paused') {\n            // Execution is paused - typically means a step is awaiting review\n            addNotification({\n              type: 'info',\n              title: 'Review Required',\n              message: `\"${exec.recipeName}\" is waiting for your review.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false,\n            });\n            stopTracking(exec.id);\n          }\n        } catch (error) {\n          console.error(`Error polling execution ${exec.id}:`, error);\n        }\n      }\n    };\n\n    // Initial poll\n    pollExecutions();\n\n    // Set up interval polling (every 3 seconds)\n    pollingIntervalRef.current = setInterval(pollExecutions, 3000);\n\n    return () => {\n      if (pollingIntervalRef.current) {\n        clearInterval(pollingIntervalRef.current);\n      }\n    };\n  }, [backgroundExecutions, addNotification, stopTracking]);\n\n  return (\n    <NotificationContext.Provider\n      value={{\n        notifications,\n        addNotification,\n        removeNotification,\n        clearAll,\n        backgroundExecutions,\n        trackExecution,\n        stopTracking,\n      }}\n    >\n      {children}\n    </NotificationContext.Provider>\n  );\n}\n\nexport function useNotifications() {\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}