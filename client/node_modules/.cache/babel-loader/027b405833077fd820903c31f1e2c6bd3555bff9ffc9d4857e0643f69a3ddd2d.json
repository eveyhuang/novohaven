{"ast":null,"code":"var _jsxFileName = \"/Users/eveyhuang/Documents/novohaven-app/client/src/context/NotificationContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport api from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationContext = /*#__PURE__*/createContext(undefined);\nexport function NotificationProvider({\n  children\n}) {\n  _s();\n  const [notifications, setNotifications] = useState([]);\n  const [backgroundExecutions, setBackgroundExecutions] = useState([]);\n  const pollingIntervalRef = useRef(null);\n  const addNotification = useCallback(notification => {\n    var _notification$autoClo, _notification$duratio;\n    const id = `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const newNotification = {\n      ...notification,\n      id,\n      autoClose: (_notification$autoClo = notification.autoClose) !== null && _notification$autoClo !== void 0 ? _notification$autoClo : true,\n      duration: (_notification$duratio = notification.duration) !== null && _notification$duratio !== void 0 ? _notification$duratio : 5000\n    };\n    setNotifications(prev => [...prev, newNotification]);\n\n    // Auto-close after duration\n    if (newNotification.autoClose) {\n      setTimeout(() => {\n        removeNotification(id);\n      }, newNotification.duration);\n    }\n    return id;\n  }, []);\n  const removeNotification = useCallback(id => {\n    setNotifications(prev => prev.filter(n => n.id !== id));\n  }, []);\n  const clearAll = useCallback(() => {\n    setNotifications([]);\n  }, []);\n  const trackExecution = useCallback((executionId, recipeName) => {\n    setBackgroundExecutions(prev => {\n      // Don't add if already tracking\n      if (prev.some(e => e.id === executionId)) {\n        return prev;\n      }\n      return [...prev, {\n        id: executionId,\n        recipeName,\n        status: 'running',\n        startedAt: new Date()\n      }];\n    });\n  }, []);\n  const stopTracking = useCallback(executionId => {\n    setBackgroundExecutions(prev => prev.filter(e => e.id !== executionId));\n  }, []);\n\n  // Poll for execution status changes\n  useEffect(() => {\n    if (backgroundExecutions.length === 0) {\n      if (pollingIntervalRef.current) {\n        clearInterval(pollingIntervalRef.current);\n        pollingIntervalRef.current = null;\n      }\n      return;\n    }\n    const pollExecutions = async () => {\n      for (const exec of backgroundExecutions) {\n        try {\n          const status = await api.getExecutionStatus(exec.id);\n\n          // Check if status changed to completed, failed, or paused (awaiting review)\n          if (status.status === 'completed') {\n            addNotification({\n              type: 'success',\n              title: 'Workflow Completed',\n              message: `\"${exec.recipeName}\" has finished successfully.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false\n            });\n            stopTracking(exec.id);\n          } else if (status.status === 'failed') {\n            addNotification({\n              type: 'error',\n              title: 'Workflow Failed',\n              message: `\"${exec.recipeName}\" encountered an error.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false\n            });\n            stopTracking(exec.id);\n          } else if (status.status === 'paused') {\n            // Execution is paused - typically means a step is awaiting review\n            addNotification({\n              type: 'info',\n              title: 'Review Required',\n              message: `\"${exec.recipeName}\" is waiting for your review.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false\n            });\n            stopTracking(exec.id);\n          }\n        } catch (error) {\n          console.error(`Error polling execution ${exec.id}:`, error);\n        }\n      }\n    };\n\n    // Initial poll\n    pollExecutions();\n\n    // Set up interval polling (every 3 seconds)\n    pollingIntervalRef.current = setInterval(pollExecutions, 3000);\n    return () => {\n      if (pollingIntervalRef.current) {\n        clearInterval(pollingIntervalRef.current);\n      }\n    };\n  }, [backgroundExecutions, addNotification, stopTracking]);\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: {\n      notifications,\n      addNotification,\n      removeNotification,\n      clearAll,\n      backgroundExecutions,\n      trackExecution,\n      stopTracking\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 157,\n    columnNumber: 5\n  }, this);\n}\n_s(NotificationProvider, \"9D5bItLE+YQRAFf4CyCE5lPxd3I=\");\n_c = NotificationProvider;\nexport function useNotifications() {\n  _s2();\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n}\n_s2(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useRef","useEffect","api","jsxDEV","_jsxDEV","NotificationContext","undefined","NotificationProvider","children","_s","notifications","setNotifications","backgroundExecutions","setBackgroundExecutions","pollingIntervalRef","addNotification","notification","_notification$autoClo","_notification$duratio","id","Date","now","Math","random","toString","substr","newNotification","autoClose","duration","prev","setTimeout","removeNotification","filter","n","clearAll","trackExecution","executionId","recipeName","some","e","status","startedAt","stopTracking","length","current","clearInterval","pollExecutions","exec","getExecutionStatus","type","title","message","error","console","setInterval","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useNotifications","_s2","context","Error","$RefreshReg$"],"sources":["/Users/eveyhuang/Documents/novohaven-app/client/src/context/NotificationContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport api from '../services/api';\n\nexport interface Notification {\n  id: string;\n  type: 'success' | 'error' | 'info' | 'warning';\n  title: string;\n  message?: string;\n  executionId?: number;\n  recipeName?: string;\n  autoClose?: boolean;\n  duration?: number;\n}\n\ninterface BackgroundExecution {\n  id: number;\n  recipeName: string;\n  status: string;\n  startedAt: Date;\n}\n\ninterface NotificationContextType {\n  notifications: Notification[];\n  addNotification: (notification: Omit<Notification, 'id'>) => string;\n  removeNotification: (id: string) => void;\n  clearAll: () => void;\n  // Background execution tracking\n  backgroundExecutions: BackgroundExecution[];\n  trackExecution: (executionId: number, recipeName: string) => void;\n  stopTracking: (executionId: number) => void;\n}\n\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\n\nexport function NotificationProvider({ children }: { children: React.ReactNode }) {\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const [backgroundExecutions, setBackgroundExecutions] = useState<BackgroundExecution[]>([]);\n  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  const addNotification = useCallback((notification: Omit<Notification, 'id'>) => {\n    const id = `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const newNotification: Notification = {\n      ...notification,\n      id,\n      autoClose: notification.autoClose ?? true,\n      duration: notification.duration ?? 5000,\n    };\n\n    setNotifications(prev => [...prev, newNotification]);\n\n    // Auto-close after duration\n    if (newNotification.autoClose) {\n      setTimeout(() => {\n        removeNotification(id);\n      }, newNotification.duration);\n    }\n\n    return id;\n  }, []);\n\n  const removeNotification = useCallback((id: string) => {\n    setNotifications(prev => prev.filter(n => n.id !== id));\n  }, []);\n\n  const clearAll = useCallback(() => {\n    setNotifications([]);\n  }, []);\n\n  const trackExecution = useCallback((executionId: number, recipeName: string) => {\n    setBackgroundExecutions(prev => {\n      // Don't add if already tracking\n      if (prev.some(e => e.id === executionId)) {\n        return prev;\n      }\n      return [...prev, {\n        id: executionId,\n        recipeName,\n        status: 'running',\n        startedAt: new Date(),\n      }];\n    });\n  }, []);\n\n  const stopTracking = useCallback((executionId: number) => {\n    setBackgroundExecutions(prev => prev.filter(e => e.id !== executionId));\n  }, []);\n\n  // Poll for execution status changes\n  useEffect(() => {\n    if (backgroundExecutions.length === 0) {\n      if (pollingIntervalRef.current) {\n        clearInterval(pollingIntervalRef.current);\n        pollingIntervalRef.current = null;\n      }\n      return;\n    }\n\n    const pollExecutions = async () => {\n      for (const exec of backgroundExecutions) {\n        try {\n          const status = await api.getExecutionStatus(exec.id);\n\n          // Check if status changed to completed, failed, or paused (awaiting review)\n          if (status.status === 'completed') {\n            addNotification({\n              type: 'success',\n              title: 'Workflow Completed',\n              message: `\"${exec.recipeName}\" has finished successfully.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false,\n            });\n            stopTracking(exec.id);\n          } else if (status.status === 'failed') {\n            addNotification({\n              type: 'error',\n              title: 'Workflow Failed',\n              message: `\"${exec.recipeName}\" encountered an error.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false,\n            });\n            stopTracking(exec.id);\n          } else if (status.status === 'paused') {\n            // Execution is paused - typically means a step is awaiting review\n            addNotification({\n              type: 'info',\n              title: 'Review Required',\n              message: `\"${exec.recipeName}\" is waiting for your review.`,\n              executionId: exec.id,\n              recipeName: exec.recipeName,\n              autoClose: false,\n            });\n            stopTracking(exec.id);\n          }\n        } catch (error) {\n          console.error(`Error polling execution ${exec.id}:`, error);\n        }\n      }\n    };\n\n    // Initial poll\n    pollExecutions();\n\n    // Set up interval polling (every 3 seconds)\n    pollingIntervalRef.current = setInterval(pollExecutions, 3000);\n\n    return () => {\n      if (pollingIntervalRef.current) {\n        clearInterval(pollingIntervalRef.current);\n      }\n    };\n  }, [backgroundExecutions, addNotification, stopTracking]);\n\n  return (\n    <NotificationContext.Provider\n      value={{\n        notifications,\n        addNotification,\n        removeNotification,\n        clearAll,\n        backgroundExecutions,\n        trackExecution,\n        stopTracking,\n      }}\n    >\n      {children}\n    </NotificationContext.Provider>\n  );\n}\n\nexport function useNotifications() {\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}